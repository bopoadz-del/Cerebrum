"""
Integration Test Generation

Auto-generates pytest tests from function signatures.
"""
import ast
import inspect
from typing import Dict, List, Optional, Any, Callable
from dataclasses import dataclass
from jinja2 import Template
import logging

logger = logging.getLogger(__name__)


@dataclass
class TestCase:
    """Represents a generated test case."""
    name: str
    description: str
    inputs: Dict[str, Any]
    expected_output: Any
    expected_exception: Optional[str]


@dataclass
class TestGenerationResult:
    """Result of test generation."""
    success: bool
    test_code: str
    test_cases: List[TestCase]
    coverage_estimate: float
    errors: List[str]


class TestGenerator:
    """
    Generates integration tests from code analysis.
    
    Supports:
    - FastAPI endpoint testing
    - Function unit testing
    - Database model testing
    """
    
    # Test template for FastAPI endpoints
    FASTAPI_TEST_TEMPLATE = Template('''
"""
Auto-generated tests for {{ module_name }}
Generated by Cerebrum Self-Coding System
"""
import pytest
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.pool import StaticPool

from {{ module_path }} import {{ module_name }}
from ..database import Base, get_db

# Setup test database
SQLALCHEMY_DATABASE_URL = "sqlite:///:memory:"
engine = create_engine(
    SQLALCHEMY_DATABASE_URL,
    connect_args={"check_same_thread": False},
    poolclass=StaticPool,
)
TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def override_get_db():
    try:
        db = TestingSessionLocal()
        yield db
    finally:
        db.close()

# Create tables
Base.metadata.create_all(bind=engine)

# Setup test client
from ..main import app
app.dependency_overrides[get_db] = override_get_db
client = TestClient(app)


{% for test in tests %}
{{ test }}
{% endfor %}
''')

    # Test template for individual functions
    FUNCTION_TEST_TEMPLATE = Template('''
"""
Auto-generated tests for {{ function_name }}
Generated by Cerebrum Self-Coding System
"""
import pytest
from {{ module_path }} import {{ function_name }}

{% for test in tests %}
{{ test }}
{% endfor %}
''')

    def generate_from_code(
        self,
        code: str,
        language: str = "python",
        test_type: str = "auto"
    ) -> TestGenerationResult:
        """
        Generate tests from code.
        
        Args:
            code: Source code to test
            language: Programming language
            test_type: Type of tests to generate (unit, integration, auto)
        
        Returns:
            TestGenerationResult with generated tests
        """
        if language != "python":
            return TestGenerationResult(
                success=False,
                test_code="",
                test_cases=[],
                coverage_estimate=0,
                errors=["Only Python test generation is supported"]
            )
        
        try:
            # Parse the code
            tree = ast.parse(code)
            
            # Find functions and classes
            functions = []
            classes = []
            
            for node in ast.walk(tree):
                if isinstance(node, ast.FunctionDef):
                    functions.append(self._analyze_function(node))
                elif isinstance(node, ast.ClassDef):
                    classes.append(self._analyze_class(node))
            
            # Generate tests based on what we found
            if any(c["type"] == "fastapi_router" for c in classes):
                return self._generate_fastapi_tests(code, functions, classes)
            else:
                return self._generate_unit_tests(code, functions, classes)
        
        except SyntaxError as e:
            return TestGenerationResult(
                success=False,
                test_code="",
                test_cases=[],
                coverage_estimate=0,
                errors=[f"Syntax error: {e}"]
            )
        except Exception as e:
            logger.error(f"Test generation error: {e}")
            return TestGenerationResult(
                success=False,
                test_code="",
                test_cases=[],
                coverage_estimate=0,
                errors=[str(e)]
            )
    
    def _analyze_function(self, node: ast.FunctionDef) -> Dict[str, Any]:
        """Analyze a function definition."""
        # Get function name
        name = node.name
        
        # Skip private functions
        if name.startswith("_"):
            return None
        
        # Get parameters
        params = []
        for arg in node.args.args:
            if arg.arg != "self" and arg.arg != "cls":
                param_info = {
                    "name": arg.arg,
                    "type": self._get_type_hint(arg),
                    "has_default": False
                }
                params.append(param_info)
        
        # Check for default values
        defaults_start = len(node.args.args) - len(node.args.defaults)
        for i, default in enumerate(node.args.defaults):
            params[defaults_start + i]["has_default"] = True
            params[defaults_start + i]["default"] = self._get_default_value(default)
        
        # Get return type
        return_type = None
        if node.returns:
            return_type = self._get_type_hint(node.returns)
        
        # Detect function type
        func_type = "regular"
        decorators = [ast.unparse(d) for d in node.decorator_list]
        if any("router." in d for d in decorators):
            func_type = "endpoint"
        elif any("pytest" in d for d in decorators):
            func_type = "test"
        
        return {
            "name": name,
            "params": params,
            "return_type": return_type,
            "type": func_type,
            "docstring": ast.get_docstring(node)
        }
    
    def _analyze_class(self, node: ast.ClassDef) -> Dict[str, Any]:
        """Analyze a class definition."""
        methods = []
        for item in node.body:
            if isinstance(item, ast.FunctionDef):
                method = self._analyze_function(item)
                if method:
                    methods.append(method)
        
        # Detect class type
        class_type = "regular"
        bases = [ast.unparse(b) for b in node.bases]
        if any("APIRouter" in b for b in bases):
            class_type = "fastapi_router"
        elif any("BaseModel" in b for b in bases):
            class_type = "pydantic_model"
        elif any("Base" in b for b in bases):
            class_type = "sqlalchemy_model"
        
        return {
            "name": node.name,
            "type": class_type,
            "methods": methods,
            "bases": bases
        }
    
    def _get_type_hint(self, node: ast.AST) -> str:
        """Extract type hint from AST node."""
        if node is None:
            return "Any"
        try:
            return ast.unparse(node)
        except:
            return "Any"
    
    def _get_default_value(self, node: ast.AST) -> Any:
        """Extract default value from AST node."""
        try:
            if isinstance(node, ast.Constant):
                return node.value
            elif isinstance(node, ast.NameConstant):
                return node.value
            elif isinstance(node, ast.List):
                return []
            elif isinstance(node, ast.Dict):
                return {}
            else:
                return None
        except:
            return None
    
    def _generate_fastapi_tests(
        self,
        code: str,
        functions: List[Dict],
        classes: List[Dict]
    ) -> TestGenerationResult:
        """Generate FastAPI endpoint tests."""
        test_cases = []
        test_code_parts = []
        
        for func in functions:
            if func["type"] != "endpoint":
                continue
            
            func_name = func["name"]
            endpoint_path = func_name.replace("_", "-")
            
            # Generate test cases
            tests = self._generate_endpoint_tests(func)
            test_code_parts.extend(tests)
            
            test_cases.append(TestCase(
                name=f"test_{func_name}",
                description=f"Test {func_name} endpoint",
                inputs={},
                expected_output=200,
                expected_exception=None
            ))
        
        # Render template
        test_code = self.FASTAPI_TEST_TEMPLATE.render(
            module_name="generated_module",
            module_path="..endpoints",
            tests=test_code_parts
        )
        
        return TestGenerationResult(
            success=True,
            test_code=test_code,
            test_cases=test_cases,
            coverage_estimate=0.7,
            errors=[]
        )
    
    def _generate_unit_tests(
        self,
        code: str,
        functions: List[Dict],
        classes: List[Dict]
    ) -> TestGenerationResult:
        """Generate unit tests for functions."""
        test_cases = []
        test_code_parts = []
        
        for func in functions:
            if func["type"] == "test":
                continue
            
            func_name = func["name"]
            tests = self._generate_function_tests(func)
            test_code_parts.extend(tests)
            
            test_cases.append(TestCase(
                name=f"test_{func_name}",
                description=f"Test {func_name} function",
                inputs={p["name"]: self._generate_test_value(p) for p in func["params"]},
                expected_output=None,
                expected_exception=None
            ))
        
        # Render template
        test_code = self.FUNCTION_TEST_TEMPLATE.render(
            function_name="generated_function",
            module_path="..module",
            tests=test_code_parts
        )
        
        return TestGenerationResult(
            success=True,
            test_code=test_code,
            test_cases=test_cases,
            coverage_estimate=0.6,
            errors=[]
        )
    
    def _generate_endpoint_tests(self, func: Dict) -> List[str]:
        """Generate test code for an endpoint."""
        func_name = func["name"]
        tests = []
        
        # Basic success test
        tests.append(f'''
def test_{func_name}_success():
    \"\"\"Test successful {func_name} request.\"\"\"
    response = client.get("/api/v1/{func_name.replace('_', '-')}")
    assert response.status_code == 200
''')
        
        # Test with parameters if applicable
        if func["params"]:
            tests.append(f'''
def test_{func_name}_with_params():
    \"\"\"Test {func_name} with query parameters.\"\"\"
    response = client.get("/api/v1/{func_name.replace('_', '-')}?limit=10")
    assert response.status_code == 200
    data = response.json()
    assert isinstance(data, list)
''')
        
        # Error case test
        tests.append(f'''
def test_{func_name}_not_found():
    \"\"\"Test {func_name} with invalid ID.\"\"\"
    response = client.get("/api/v1/{func_name.replace('_', '-')}/invalid-id")
    assert response.status_code == 404
''')
        
        return tests
    
    def _generate_function_tests(self, func: Dict) -> List[str]:
        """Generate test code for a function."""
        func_name = func["name"]
        tests = []
        
        # Generate test values for parameters
        param_values = []
        for param in func["params"]:
            value = self._generate_test_value(param)
            param_values.append(f"{param['name']}={value}")
        
        param_str = ", ".join(param_values)
        
        # Basic success test
        tests.append(f'''
def test_{func_name}_success():
    \"\"\"Test {func_name} with valid inputs.\"\"\"
    result = {func_name}({param_str})
    assert result is not None
''')
        
        # Edge case test
        tests.append(f'''
def test_{func_name}_edge_cases():
    \"\"\"Test {func_name} edge cases.\"\"\"
    # Test with empty inputs
    # Test with boundary values
    pass
''')
        
        return tests
    
    def _generate_test_value(self, param: Dict) -> str:
        """Generate a test value for a parameter."""
        param_type = param.get("type", "Any")
        
        if "str" in param_type:
            return '"test_value"'
        elif "int" in param_type:
            return "42"
        elif "float" in param_type:
            return "3.14"
        elif "bool" in param_type:
            return "True"
        elif "list" in param_type or "List" in param_type:
            return "[]"
        elif "dict" in param_type or "Dict" in param_type:
            return "{}"
        else:
            return "None"
    
    def generate_from_signature(
        self,
        func: Callable,
        num_cases: int = 3
    ) -> TestGenerationResult:
        """Generate tests from a function signature."""
        sig = inspect.signature(func)
        
        test_cases = []
        for i in range(num_cases):
            test_cases.append(TestCase(
                name=f"test_{func.__name__}_case_{i+1}",
                description=f"Test case {i+1} for {func.__name__}",
                inputs={},
                expected_output=None,
                expected_exception=None
            ))
        
        # Generate test code
        test_code = f'''
def test_{func.__name__}_basic():
    \"\"\"Basic test for {func.__name__}.\"\"\"
    # TODO: Implement test
    pass
'''
        
        return TestGenerationResult(
            success=True,
            test_code=test_code,
            test_cases=test_cases,
            coverage_estimate=0.5,
            errors=[]
        )


class TestRunner:
    """Runs generated tests and reports results."""
    
    def run_tests(self, test_code: str, timeout: int = 60) -> Dict[str, Any]:
        """Run test code and return results."""
        import tempfile
        import subprocess
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='_test.py', delete=False) as f:
            f.write(test_code)
            test_file = f.name
        
        try:
            result = subprocess.run(
                ["python", "-m", "pytest", test_file, "-v", "--tb=short"],
                capture_output=True,
                text=True,
                timeout=timeout
            )
            
            return {
                "success": result.returncode == 0,
                "returncode": result.returncode,
                "stdout": result.stdout,
                "stderr": result.stderr,
                "passed": result.returncode == 0
            }
        except subprocess.TimeoutExpired:
            return {
                "success": False,
                "error": "Test execution timed out",
                "passed": False
            }
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "passed": False
            }
        finally:
            try:
                import os
                os.unlink(test_file)
            except:
                pass
